===========================????==============================================
# todo: 这里有一个BUG
"""
    这里写的代码是异步代码，也就是对并发支持度高，对于读取来说
    并不会产生问题，但是对于写入，如果写入的某些值是基于前面
    的运行结果，那么就会出错。例如一个写入的程序还没执行完毕，
    另一个写入程序获得的auto inrement的值就可能是"老"的值，
    这显然是个错误。
        看来写入，能不能并发，该不该并发，都要好好研究考虑
    ·编写写入控制锁，避免冲突，我想这个控制锁是基于写入相同table时的
        同时看某些情况下，能否多个写入合并，例如saveMangObj

"""

===========================????==============================================
············
  ··
    这里涉及到的重要技术：
      ·对象唯一标识生成技术
      ·对象有序迭代技术
      ·对象一致性判定技术
  ·比较容易实现的是判断两个对象的包含关系，例如一个对象A的所有键以及键的路径都包含在另外一个对象B中
    常见的情况是A是早先的对象，由于需要，增添了某些属性，就成了B对象了
············
---------------------------20180831----------------------------------------------
·为一个小测试程序编写了配套的Model，同时为了便于一次写入多行数据，在orm中编写了saveMany
    函数。这个小测试程序从网页上批量获取数据，然后存入数据库中。
---------------------------20180831----------------------------------------------
---------------------------20180823----------------------------------------------
已经解决：
    a.mate注释的位置调试正确，用的table_for_test和users对象做的测试
---------------------------20180823----------------------------------------------
todo:
    0.mate注释的位置不对，用的table_for_test和users对象做的测试
已经解决：
    a.已经对对象的读出机制进行的较为完整的测试
---------------------------20180823----------------------------------------------
---------------------------20180821----------------------------------------------
todo:
    0.发现如果对象本身是个Array，那么写入时，没有标明对象原来的Array类型，导致重新读出时，变成了Object类型
    1.发现了javascript中可以构造出循环对象
已经解决：
    a.当对象的key或者value中存在特殊字符时，如何让json正确解析
        方案，用python自己的json模块去格式化含有特殊字符的value，json模块会考虑到各种情况
        并且处理好各种情况，不用自己造轮子
    b.当对象中有list嵌套时候，正确get到对象，如下复杂度对象通过测试
        "{\"name\":\"testArray\",\"aa\":[[\"algebra\",\"leanear\",\"theta\"],1,2,{\"mate\":false},{\"mm\":[2,3,4]}]}"
    c.对对象的读出机制进行了完整的测试
---------------------------20180821----------------------------------------------
---------------------------20180820----------------------------------------------
·成功实现任意对象的写入
·基本成功实现任意对象的json读出
todo:
    0.当对象的key或者value中存在特殊字符时，如何让json正确解析
        例如，表submission_data_note中mate为content的data(的exStorage)存储的是
            剪藏的网页，总是导致拼凑json后解析失败
        我猜这也是note插件采用thrift传递剪藏后的数据，而不是采用字符串传递的原因
    1.完善对象中有list时，读出仍然还原成list
    2.完善对象读出时，附加相应注释
    3.对对象的读出机制进行完整的测试，目前还未测试如下：
        当对象是string、number、bool或者对象是空dict和list时，能否正确
            读出，以及能否正确处理注释
    4.完善对象注释的写入机制
---------------------------20180820----------------------------------------------
---------------------------20180724----------------------------------------------
todo:
    .绕过原本的一行一个实例，然后每次调用save方法写入的方案，直接调用相应class的
        saveObj方法。这是借鉴原作在查找时直接调用类的findAll的写法，如下：
            users = yield from User.findAll(orderBy = 'created_at desc', limit = (p.offset, p.limit))
        给saveObj传入需要写入的object，或者其他可能需要的参数
        然后进行处理和迭代，最后分行写入或者一齐写入
    .研究下有没有类似executemany的类似的一齐写入的api，并且写入失败可以回滚
    .稍改动下orm，使其能够区分某些写入时候不用传值的column，例如timestamp
        目前的情况下，只能够区分主键和非主键。
---------------------------20180724----------------------------------------------
---------------------------20180723----------------------------------------------
/**
 0.0基于hash的算法肯定存在碰撞问题，这个是需要考虑的。
 0.由于自己数据库设计并不完善，所以很多缺陷要靠程序上的设计去补充。
    .例如，多种长度相仿的数据类型，如果能够转换成字符串存储的，就转换成字符串
      这样就可以统一存储在varchar类型的一列中。同时建立一个存储类型列，取用数据
      的时候，根据存储类型列，把取出的数据转换成相应类型的数据，我这样做意图减少
      表中列的数目。不知道是让很多列存在null，还是这个样子效率更高？
      eg:user_note表的format,data两列
    .例如，还有一个复用某一列的办法。在表table_info_note中，order的主要用意是标记
      每个对象中mate存取时候的迭代顺序，一般为正整数。如果我想复用这个列，可以规定
      正整数部分表示mate的迭代顺序，-1表示相应的mate处于删除或弃用的状态，-100 ~ -199
      表示对应的hash列存储的是remark的索引hash。对于remark来说，last_row一列可以标记成
      -100。
 1.每个存贮对象一个表。
 2.设立路径列，路径列一样，就属于同一个对象。
      考虑路径用什么作为分隔分隔符？
        例如用”.”号作为分隔符，那么路径的名称中不能出现“.”号
      或者在这样规模较小的表中，可以使用每一节路径的数字代码串联
      起来表示路径。
 3.设立键名称列，str，用于存储对象中每个键的名字。路径和名称列一样，
    即可判定为同一个<元>,我们这里记录<元>随时间的变化。
 4.设立时间列，以便追踪对象随时间的变化。
*/
/**
 5.考虑个别键的内容可能存在大块文本，可以设立转储表， 专用于存储大段文本
    或者考虑后来存储大块数据或者影像。
 6.最终是要达到<自动化> 的目的。例如传进来一个新对象，根据上述规则，自动建立相应
    的新表，自动填充表。目前表名的命名还是人工的，以后可以根据对象的唯一识别特征
    等自动命名。
 7.目前还不能做到全自动判定一个对象是否是全新的，我们可以基于对象的<元>并且<元>的
    路径结构来自动判定对象一致，要构造出对象的唯一识别特征码，但程序目前无法包含更大的外部环境信息，所以绝对的
    一致性还需要人工判定。
*/
/**
 9.对于这的数据，当然也可以采用分表然后联合查询的办法。例如数据值和时间两列单成一表。
    但这是数据量不大的小测试，加上自己不熟，暂时采用目前都在一表中的做法。
 10.有的时候，同一个对象有了一点点改动，例如增减了一两个小属性，或者重命名了一个属性，如果
    开发者主观上仍然要继续沿用旧表，该怎样兼容呢？可以单独记录哪些属性处于删除状态，但是
    并不真正删除数据，只是查询输出的时候，并不输出。也就是为传进来的对象内部自行增加了一个
    删除状态属性。当然这个测试暂不实现这个做法。
 11.为了快捷取出最后一次存储进去的对象数据，可以设置一个属性，记录最后存储的每个<元>的行号，
    取出时，直接查询指定行号，然后拼接即可。
 12.设置对象值类型列。在本次测试中，可以不设。原则上把所有的<元>的值都可以存储为str类型，因为
    对象都是通过json传过来的，也就是都是字符串化的。但是为以后扩展需要，可以设定此列。目前这列
    还有一个用处，就是区分<元>的值是另一个对象，还是一般的可以字符串化的值(bool,number,str,array)
    如果是对象，这一列的键值就是Object；还可以区分是<元>的值是否被转储，如果转储，这一列的值
    就是exStorage。
 13.通过测试JSON.stringfy函数得知，Json对象的所有键都被看做字符串对象，在json化的时候，都是
    用双引号包裹的，Json的键的值，如果是字符串，则会被双引号包裹，如果是一般的bool，则false
    字样不会被双引号包裹，同理数字类型也不会被双引号包裹。
    JSON.stringfy函数会把值为undefined的属性直接忽略掉，在转换后的字符串中，并不
    包含这个属性名。
*/
/**
 14.对于一个确定的对象，可以尝试建立他的<元>指纹迭代树，每次存取按照迭代指纹操作。
*/
/**
 a.a 数据行的总长度是受mysql行总size限制的。
 a.假定<元>键值中不存在双引号，存入之前进行检测，检测到报错。
 b.<元>键值(<元>的名称)name受数据库限制，5.0版本之后是长度不得超过255个字元
 c.<元>的路径path限制，5.0版本之后是长度不得超过800个字元
 c.<元>的值data限制，5.0版本之后是长度不得超过1200个字元
*/

use fortest;
/**
  ··
    这里涉及到的重要技术：
      ·对象唯一标识生成技术
      ·对象有序迭代技术
      ·对象一致性判定技术
*/
---------------------------20180723----------------------------------------------
---------------------------20180712----------------------------------------------
1.本分支是在bootstrap前期的基础上，专门为配合MachineIntelligence项目初步开发的后台
    测试程序，由于MachineIntelligence可以简写为MI，所以本分支命名为：
        MI@backStage@i
---------------------------20180712----------------------------------------------
